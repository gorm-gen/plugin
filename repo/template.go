package repo

func (r *Repo) baseTemplate() string {
	return `// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"errors"
	"sync"

	"gorm.io/gorm"

	"{{.GormDBVarPkg}}"

	"{{.GenQueryPkg}}"
)

var once sync.Once
var q *query.Query

func GetQuery() *query.Query {
	once.Do(func() {
		q = query.Use({{.GormDBVar}})
	})
	return q
}

func IsRealErr(err error) bool {
	return !errors.Is(err, gorm.ErrRecordNotFound) && !errors.Is(err, context.DeadlineExceeded) && !errors.Is(err, context.Canceled)
}
`
}

func (r *Repo) genBaseTemplate() string {
	return `// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.

package {{.Package}}

import (
	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"

	"{{.ZapVarPkg}}"

	"{{.GenQueryPkg}}"

    "{{.RepoPkg}}"
)

type {{.StructName}} struct {
	q      *query.Query
	logger *zap.Logger
}

func New() *{{.StructName}} {
	return &{{.StructName}}{
		q:      {{.RepoPkgName}}.GetQuery(),
		logger: global.Logger,
	}
}

type Option func(*{{.StructName}}) gen.Condition

func WithID(id int64) Option {
	return func({{.Abbr}} *{{.StructName}}) gen.Condition {
		return {{.Abbr}}.q.{{.StructName}}.ID.Eq(id)
	}
}

type UpdateOption func(*{{.StructName}}) field.AssignExpr

type OrderOption func(*{{.StructName}}) field.Expr

func OrderIDDesc() OrderOption {
	return func({{.Abbr}} *{{.StructName}}) field.Expr {
		return {{.Abbr}}.q.{{.StructName}}.ID.Desc()
	}
}

type RelationOption func(*{{.StructName}}) field.RelationField

func RelationAll() RelationOption {
	return func({{.Abbr}} *{{.StructName}}) field.RelationField {
		return field.Associations
	}
}
`
}

func (r *Repo) genCountTemplate() string {
	return `// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.

package {{.Package}}

import (
	"context"

	"go.uber.org/zap"
	"gorm.io/gen"

	"{{.GenQueryPkg}}"

    "{{.RepoPkg}}"
)

type CountData struct {
	tx            *query.Query
	qTx           *query.QueryTx
	conditionOpts []Option
}

func NewCountData() *CountData {
	return &CountData{
		conditionOpts: make([]Option, 0),
	}
}

func (c *CountData) SetTx(tx *query.Query) *CountData {
	c.tx = tx
	c.qTx = nil
	return c
}

// SetQueryTx 设置为手动事务
func (c *CountData) SetQueryTx(tx *query.QueryTx) *CountData {
	c.qTx = tx
	c.tx = nil
	return c
}

func (c *CountData) SetConditionOpts(opts ...Option) *CountData {
	c.conditionOpts = opts
	return c
}

// Count 获取数据总条数
func ({{.Abbr}} *{{.StructName}}) Count(ctx context.Context, cd *CountData) (int64, error) {
	{{.Abbr}}q := {{.Abbr}}.q.{{.StructName}}
	if cd.tx != nil {
		{{.Abbr}}q = cd.tx.{{.StructName}}
	}
	if cd.qTx != nil {
		{{.Abbr}}q = cd.qTx.{{.StructName}}
	}
	{{.Abbr}}r := {{.Abbr}}q.WithContext(ctx)
	errFields := make([]zap.Field, 0)
	if len(cd.conditionOpts) > 0 {
		conditions := make([]gen.Condition, 0, len(cd.conditionOpts))
		for _, opt := range cd.conditionOpts {
			conditions = append(conditions, opt({{.Abbr}}))
		}
		if len(conditions) > 0 {
			errFields = append(errFields, zap.Any("conditions", conditions))
			{{.Abbr}}r = {{.Abbr}}r.Where(conditions...)
		}
	}
	count, err := {{.Abbr}}r.Count()
	if err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			errFields = append(errFields, zap.Error(err))
			{{.Abbr}}.logger.Error("【{{.StructName}}.Count】失败", errFields...)
		}
		return 0, err
	}
	return count, nil
}
`
}

func (r *Repo) genCreateTemplate() string {
	return `// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.

package {{.Package}}

import (
	"context"

	"go.uber.org/zap"

	"{{.GenQueryPkg}}"

    "{{.RepoPkg}}"

    "{{.ModelPkg}}"
)

type CreateData struct {
	tx        *query.Query
	qTx       *query.QueryTx
	values    []*{{.ModelName}}.{{.StructName}}
	batchSize int
}

func NewCreateData() *CreateData {
	return &CreateData{}
}

func (c *CreateData) SetTx(tx *query.Query) *CreateData {
	c.tx = tx
	c.qTx = nil
	return c
}

func (c *CreateData) SetQueryTx(tx *query.QueryTx) *CreateData {
	c.qTx = tx
	c.tx = nil
	return c
}

func (c *CreateData) SetValues(values ...*{{.ModelName}}.{{.StructName}}) *CreateData {
	c.values = values
	return c
}

func (c *CreateData) SetBatchSize(batchSize uint) *CreateData {
	c.batchSize = int(batchSize)
	return c
}

// Create 添加数据
func ({{.Abbr}} *{{.StructName}}) Create(ctx context.Context, cd *CreateData) (err error) {
	length := len(cd.values)
	if length == 0 {
		return nil
	}
	{{.Abbr}}q := {{.Abbr}}.q.{{.StructName}}
	if cd.tx != nil {
		{{.Abbr}}q = cd.tx.{{.StructName}}
	}
	if cd.qTx != nil {
		{{.Abbr}}q = cd.qTx.{{.StructName}}
	}
	{{.Abbr}}r := {{.Abbr}}q.WithContext(ctx)
	errFields := make([]zap.Field, 0)
	if length > 1 && cd.batchSize > 0 {
		errFields = append(errFields, zap.Int("batchSize", cd.batchSize))
		err = cr.CreateInBatches(cd.values, cd.batchSize)
	} else {
		err = cr.Create(cd.values...)
	}
	if err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			errFields = append(errFields, zap.Any("values", cd.values))
			errFields = append(errFields, zap.Error(err))
			{{.Abbr}}.logger.Error("【{{.StructName}}.Create】失败", errFields...)
		}
		return err
	}
	return nil
}
`
}
