package repository

func (r *Repository) baseTemplate() string {
	return `// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"errors"
	"sync"

	"gorm.io/gorm"

	"{{.GormDBVarPkg}}"

	"{{.GenQueryPkg}}"
)

var once sync.Once
var q *query.Query

func GetQuery() *query.Query {
	once.Do(func() {
		q = query.Use({{.GormDBVar}})
	})
	return q
}

// IsRealErr 是否为非超时和查询不到的错误
func IsRealErr(err error) bool {
	return !errors.Is(err, gorm.ErrRecordNotFound) &&
		!errors.Is(err, context.DeadlineExceeded) &&
		!errors.Is(err, context.Canceled)
}
`
}

func (r *Repository) genBaseTemplate() string {
	return `// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.

package {{.Package}}

import (
{{range .Imports}}{{.}}{{end}}
)

// {{.StructName}} 仓库/Repository
type {{.StructName}} struct {
	q            *query.Query
	db           *gorm.DB
	logger       *zap.Logger
	unscoped     bool
	newTableName *string
}

// Option {{.StructName}}仓库初始化选项
type Option func(*{{.StructName}})

func WithQuery(q *query.Query) Option {
	return func({{.Abbr}} *{{.StructName}}) {
		{{.Abbr}}.q = q
	}
}

func WithLogger(logger *zap.Logger) Option {
	return func({{.Abbr}} *{{.StructName}}) {
		{{.Abbr}}.logger = logger
	}
}

func WithDB(db *gorm.DB) Option {
	return func({{.Abbr}} *{{.StructName}}) {
		{{.Abbr}}.db = db
	}
}

func WithNewTableName(newTableName string) Option {
	return func({{.Abbr}} *{{.StructName}}) {
		{{.Abbr}}.newTableName = &newTableName
	}
}

func WithUnscoped() Option {
	return func({{.Abbr}} *{{.StructName}}) {
		{{.Abbr}}.unscoped = true
	}
}

// New {{.StructName}}仓库初始化
func New(opts ...Option) *{{.StructName}} {
	{{.Abbr}} := &{{.StructName}}{
		q:      {{.RepoPkgName}}.GetQuery(),
		db:     {{.GormDBVar}},
		logger: {{.ZapVar}},
	}
	for _, opt := range opts {
		opt({{.Abbr}})
	}
	return {{.Abbr}}
}

// ConditionOption 字段条件筛选选项
type ConditionOption func(*{{.StructName}}) gen.Condition

// Condition 自定义字段条件筛选
func Condition(condition gen.Condition) ConditionOption {
	return func(*{{.StructName}}) gen.Condition {
		return condition
	}
}
{{range .Conditions}}{{.}}{{end}}
// UpdateOption 数据更新选项
type UpdateOption func(*{{.StructName}}) field.AssignExpr

// Update 自定义数据更新
func Update(update field.AssignExpr) UpdateOption {
    return func(*{{.StructName}}) field.AssignExpr {
        return update
    }
}
{{range .Updates}}{{.}}{{end}}
// OrderOption 数据排序选项
type OrderOption func(*{{.StructName}}) field.Expr

// Order 自定义数据排序
func OrderBy(order field.Expr) OrderOption {
    return func(*{{.StructName}}) field.Expr {
        return order
    }
}
{{range .Orders}}{{.}}{{end}}
// RelationOption 关联模型预加载选项
type RelationOption func(*{{.StructName}}) field.RelationField

// Relation 自定义关联模型预加载
func Relation(relation field.RelationField) RelationOption {
	return func(*{{.StructName}}) field.RelationField {
		return relation
	}
}

func RelationAll() RelationOption {
	return func(*{{.StructName}}) field.RelationField {
		return field.Associations
	}
}
`
}

func (r *Repository) genCountTemplate() string {
	return `// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"

	"go.uber.org/zap"
	"gorm.io/gen"

	"{{.GenQueryPkg}}"

    "{{.RepoPkg}}"
)

type count struct {
	core          *{{.StructName}}
	tx            *query.Query
	qTx           *query.QueryTx
	unscoped      bool
	conditionOpts []ConditionOption
}

// Count 获取数据总条数
func ({{.Abbr}} *{{.StructName}}) Count() *count {
	return &count{
		core:          {{.Abbr}},
		unscoped:      {{.Abbr}}.unscoped,
		conditionOpts: make([]ConditionOption, 0),
	}
}

// Tx 设置为事务
func (c *count) Tx(tx *query.Query) *count {
	c.tx = tx
	c.qTx = nil
	return c
}

// QueryTx 设置为手动事务
func (c *count) QueryTx(tx *query.QueryTx) *count {
	c.qTx = tx
	c.tx = nil
	return c
}

func (c *count) Unscoped() *count {
	c.unscoped = true
	return c
}

func (c *count) Where(opts ...ConditionOption) *count {
	c.conditionOpts = append(c.conditionOpts, opts...)
	return c
}

// Do 执行获取数据总条数
func (c *count) Do(ctx context.Context) (int64, error) {
	cq := c.core.q.{{.StructName}}
	if c.tx != nil {
		cq = c.tx.{{.StructName}}
	}
	if c.qTx != nil {
		cq = c.qTx.{{.StructName}}
	}
	cr := cq.WithContext(ctx)
	if c.core.newTableName != nil && *c.core.newTableName != "" {
		cr = cq.Table(*c.core.newTableName).WithContext(ctx)
	}
	if c.unscoped {
		cr = cr.Unscoped()
	}
	errFields := make([]zap.Field, 0)
	if len(c.conditionOpts) > 0 {
		conditions := make([]gen.Condition, 0, len(c.conditionOpts))
		for _, opt := range c.conditionOpts {
			conditions = append(conditions, opt(c.core))
		}
		if len(conditions) > 0 {
			errFields = append(errFields, zap.Any("conditions", conditions))
			cr = cr.Where(conditions...)
		}
	}
	count, err := cr.Count()
	if err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			errFields = append(errFields, zap.Error(err))
			c.core.logger.Error("【{{.StructName}}.Count】失败", errFields...)
		}
		return 0, err
	}
	return count, nil
}
`
}

func (r *Repository) genCreateTemplate() string {
	return `// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"

	"go.uber.org/zap"

	"{{.GenQueryPkg}}"

    "{{.RepoPkg}}"

    "{{.ModelPkg}}"
)

type create struct {
	core      *{{.StructName}}
	tx        *query.Query
	qTx       *query.QueryTx
	unscoped  bool
	values    []*{{.ModelName}}.{{.StructName}}
	batchSize int
}

// Create 添加数据
func ({{.Abbr}} *{{.StructName}}) Create() *create {
	return &create{
		core:     {{.Abbr}},
		unscoped: {{.Abbr}}.unscoped,
		values:   make([]*{{.ModelName}}.{{.StructName}}, 0),
	}
}

// Tx 设置为事务
func (c *create) Tx(tx *query.Query) *create {
	c.tx = tx
	c.qTx = nil
	return c
}

// QueryTx 设置为手动事务
func (c *create) QueryTx(tx *query.QueryTx) *create {
	c.qTx = tx
	c.tx = nil
	return c
}

func (c *create) Unscoped() *create {
	c.unscoped = true
	return c
}

func (c *create) Values(values ...*{{.ModelName}}.{{.StructName}}) *create {
	c.values = append(c.values, values...)
	return c
}

// BatchSize 当批量插入时指定创建的数量
func (c *create) BatchSize(batchSize uint) *create {
	c.batchSize = int(batchSize)
	return c
}

// Do 执行添加数据
func (c *create) Do(ctx context.Context) (err error) {
	length := len(c.values)
	if length == 0 {
		return nil
	}
	cq := c.core.q.{{.StructName}}
	if c.tx != nil {
		cq = c.tx.{{.StructName}}
	}
	if c.qTx != nil {
		cq = c.qTx.{{.StructName}}
	}
	cr := cq.WithContext(ctx)
	if c.core.newTableName != nil && *c.core.newTableName != "" {
		cr = cq.Table(*c.core.newTableName).WithContext(ctx)
	}
	if c.unscoped {
		cr = cr.Unscoped()
	}
	errFields := make([]zap.Field, 0)
	if length > 1 && c.batchSize > 0 {
		errFields = append(errFields, zap.Int("batchSize", c.batchSize))
		err = cr.CreateInBatches(c.values, c.batchSize)
	} else {
		err = cr.Create(c.values...)
	}
	if err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			errFields = append(errFields, zap.Any("values", c.values))
			errFields = append(errFields, zap.Error(err))
			c.core.logger.Error("【{{.StructName}}.Create】失败", errFields...)
		}
		return err
	}
	return nil
}
`
}

func (r *Repository) genDeleteTemplate() string {
	return `// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"

	"go.uber.org/zap"
    "gorm.io/gen"

	"{{.GenQueryPkg}}"

    "{{.RepoPkg}}"
)

type delete struct {
	core          *{{.StructName}}
	tx            *query.Query
	qTx           *query.QueryTx
	unscoped      bool
	conditionOpts []ConditionOption
}

// Delete 删除数据
func ({{.Abbr}} *{{.StructName}}) Delete() *delete {
	return &delete{
		core:          {{.Abbr}},
		unscoped:      {{.Abbr}}.unscoped,
		conditionOpts: make([]ConditionOption, 0),
	}
}

// Tx 设置为事务
func (d *delete) Tx(tx *query.Query) *delete {
	d.tx = tx
	d.qTx = nil
	return d
}

// QueryTx 设置为手动事务
func (d *delete) QueryTx(tx *query.QueryTx) *delete {
	d.qTx = tx
	d.tx = nil
	return d
}

func (d *delete) Unscoped() *delete {
	d.unscoped = true
	return d
}

func (d *delete) Where(opts ...ConditionOption) *delete {
	d.conditionOpts = append(d.conditionOpts, opts...)
	return d
}

// Do 执行删除数据
func (d *delete) Do(ctx context.Context) (int64, error) {
	dq := d.core.q.{{.StructName}}
	if d.tx != nil {
		dq = d.tx.{{.StructName}}
	}
	if d.qTx != nil {
		dq = d.qTx.{{.StructName}}
	}
	dr := dq.WithContext(ctx)
	if d.core.newTableName != nil && *d.core.newTableName != "" {
		dr = dq.Table(*d.core.newTableName).WithContext(ctx)
	}
	if d.unscoped {
		dr = dr.Unscoped()
	}
	errFields := make([]zap.Field, 0)
	if len(d.conditionOpts) > 0 {
		conditions := make([]gen.Condition, 0, len(d.conditionOpts))
		for _, opt := range d.conditionOpts {
			conditions = append(conditions, opt(d.core))
		}
		if len(conditions) > 0 {
			errFields = append(errFields, zap.Any("conditions", conditions))
			dr = dr.Where(conditions...)
		}
	}
	res, err := dr.Delete()
	if err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			errFields = append(errFields, zap.Error(err))
			d.core.logger.Error("【{{.StructName}}.Delete】失败", errFields...)
		}
		return 0, err
	}
	return res.RowsAffected, nil
}
`
}

func (r *Repository) genFirstTemplate() string {
	return `// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"

	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"
	"gorm.io/gorm/clause"

	"{{.GenQueryPkg}}"

    "{{.RepoPkg}}"

    "{{.ModelPkg}}"
)

type first struct {
	core          *{{.StructName}}
	tx            *query.Query
	qTx           *query.QueryTx
	lock          clause.Expression
	unscoped      bool
	selects       []field.Expr
	relationOpts  []RelationOption
	conditionOpts []ConditionOption
}

// First 获取第一条记录（主键升序）
func ({{.Abbr}} *{{.StructName}}) First() *first {
	return &first{
		core:          {{.Abbr}},
		unscoped:      {{.Abbr}}.unscoped,
		selects:       make([]field.Expr, 0),
		relationOpts:  make([]RelationOption, 0),
		conditionOpts: make([]ConditionOption, 0),
	}
}

// Tx 设置为事务
func (f *first) Tx(tx *query.Query) *first {
	f.tx = tx
	f.qTx = nil
	return f
}

// QueryTx 设置为手动事务
func (f *first) QueryTx(tx *query.QueryTx) *first {
	f.qTx = tx
	f.tx = nil
	return f
}

func (f *first) Select(field ...field.Expr) *first {
	f.selects = append(f.selects, field...)
	return f
}

func (f *first) ForUpdate() *first {
	f.lock = clause.Locking{Strength: clause.LockingStrengthUpdate}
	return f
}

func (f *first) ForUpdateSkipLocked() *first {
	f.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsSkipLocked}
	return f
}

func (f *first) ForUpdateNoWait() *first {
	f.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsNoWait}
	return f
}

func (f *first) ForShare() *first {
	f.lock = clause.Locking{Strength: clause.LockingStrengthShare}
	return f
}

func (f *first) ForShareSkipLocked() *first {
	f.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsSkipLocked}
	return f
}

func (f *first) ForShareNoWait() *first {
	f.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsNoWait}
	return f
}

func (f *first) Unscoped() *first {
	f.unscoped = true
	return f
}

func (f *first) Relation(opts ...RelationOption) *first {
	f.relationOpts = append(f.relationOpts, opts...)
	return f
}

func (f *first) Where(opts ...ConditionOption) *first {
	f.conditionOpts = append(f.conditionOpts, opts...)
	return f
}

// Do 执行获取第一条记录（主键升序）
func (f *first) Do(ctx context.Context) (*{{.ModelName}}.{{.StructName}}, error) {
	fq := f.core.q.{{.StructName}}
	if f.tx != nil {
		fq = f.tx.{{.StructName}}
	}
	if f.qTx != nil {
		fq = f.qTx.{{.StructName}}
	}
	fr := fq.WithContext(ctx)
	if f.core.newTableName != nil && *f.core.newTableName != "" {
		fr = fq.Table(*f.core.newTableName).WithContext(ctx)
	}
	if len(f.selects) > 0 {
		if f.core.newTableName == nil {
			fr = fr.Select(f.selects...)
		} else {
			fs := make([]field.Expr, 0, len(f.selects))
			for _, v := range f.selects {
				fs = append(fs, field.NewField(*f.core.newTableName, v.ColumnName().String()))
			}
			fr = fr.Select(fs...)
		}
	}
	if f.unscoped {
		fr = fr.Unscoped()
	}
	if (f.tx != nil || f.qTx != nil) && f.lock != nil {
		fr = fr.Clauses(f.lock)
	}
	errFields := make([]zap.Field, 0)
	if len(f.conditionOpts) > 0 {
		conditions := make([]gen.Condition, 0, len(f.conditionOpts))
		for _, opt := range f.conditionOpts {
			conditions = append(conditions, opt(f.core))
		}
		if len(conditions) > 0 {
			errFields = append(errFields, zap.Any("conditions", conditions))
			fr = fr.Where(conditions...)
		}
	}
	if len(f.relationOpts) > 0 {
		relations := make([]field.RelationField, 0, len(f.relationOpts))
		for _, opt := range f.relationOpts {
			relations = append(relations, opt(f.core))
		}
		if len(relations) > 0 {
			errFields = append(errFields, zap.Any("relations", relations))
			fr = fr.Preload(relations...)
		}
	}
	res, err := fr.First()
	if err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			errFields = append(errFields, zap.Error(err))
			f.core.logger.Error("【{{.StructName}}.First】失败", errFields...)
		}
		return nil, err
	}
	return res, nil
}
`
}

func (r *Repository) genLastTemplate() string {
	return `// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"

	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"
	"gorm.io/gorm/clause"

	"{{.GenQueryPkg}}"

    "{{.RepoPkg}}"

    "{{.ModelPkg}}"
)

type last struct {
	core          *{{.StructName}}
	tx            *query.Query
	qTx           *query.QueryTx
	lock          clause.Expression
	unscoped      bool
	selects       []field.Expr
	relationOpts  []RelationOption
	conditionOpts []ConditionOption
}

// Last 获取最后一条记录（主键降序）
func ({{.Abbr}} *{{.StructName}}) Last() *last {
	return &last{
		core:          {{.Abbr}},
		unscoped:      {{.Abbr}}.unscoped,
		selects:       make([]field.Expr, 0),
		relationOpts:  make([]RelationOption, 0),
		conditionOpts: make([]ConditionOption, 0),
	}
}

// Tx 设置为事务
func (l *last) Tx(tx *query.Query) *last {
	l.tx = tx
	l.qTx = nil
	return l
}

// QueryTx 设置为手动事务
func (l *last) QueryTx(tx *query.QueryTx) *last {
	l.qTx = tx
	l.tx = nil
	return l
}

func (l *last) Select(field ...field.Expr) *last {
	l.selects = append(l.selects, field...)
	return l
}

func (l *last) ForUpdate() *last {
	l.lock = clause.Locking{Strength: clause.LockingStrengthUpdate}
	return l
}

func (l *last) ForUpdateSkipLocked() *last {
	l.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsSkipLocked}
	return l
}

func (l *last) ForUpdateNoWait() *last {
	l.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsNoWait}
	return l
}

func (l *last) ForShare() *last {
	l.lock = clause.Locking{Strength: clause.LockingStrengthShare}
	return l
}

func (l *last) ForShareSkipLocked() *last {
	l.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsSkipLocked}
	return l
}

func (l *last) ForShareNoWait() *last {
	l.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsNoWait}
	return l
}

func (l *last) Unscoped() *last {
	l.unscoped = true
	return l
}

func (l *last) Relation(opts ...RelationOption) *last {
	l.relationOpts = append(l.relationOpts, opts...)
	return l
}

func (l *last) Where(opts ...ConditionOption) *last {
	l.conditionOpts = append(l.conditionOpts, opts...)
	return l
}

// Do 执行获取最后一条记录（主键降序）
func (l *last) Do(ctx context.Context) (*{{.ModelName}}.{{.StructName}}, error) {
	lq := l.core.q.{{.StructName}}
	if l.tx != nil {
		lq = l.tx.{{.StructName}}
	}
	if l.qTx != nil {
		lq = l.qTx.{{.StructName}}
	}
	lr := lq.WithContext(ctx)
	if l.core.newTableName != nil && *l.core.newTableName != "" {
		lr = lq.Table(*l.core.newTableName).WithContext(ctx)
	}
	if len(l.selects) > 0 {
		if l.core.newTableName == nil {
			lr = lr.Select(l.selects...)
		} else {
			fs := make([]field.Expr, 0, len(l.selects))
			for _, v := range l.selects {
				fs = append(fs, field.NewField(*l.core.newTableName, v.ColumnName().String()))
			}
			lr = lr.Select(fs...)
		}
	}
	if l.unscoped {
		lr = lr.Unscoped()
	}
	if (l.tx != nil || l.qTx != nil) && l.lock != nil {
		lr = lr.Clauses(l.lock)
	}
	errFields := make([]zap.Field, 0)
	if len(l.conditionOpts) > 0 {
		conditions := make([]gen.Condition, 0, len(l.conditionOpts))
		for _, opt := range l.conditionOpts {
			conditions = append(conditions, opt(l.core))
		}
		if len(conditions) > 0 {
			errFields = append(errFields, zap.Any("conditions", conditions))
			lr = lr.Where(conditions...)
		}
	}
	if len(l.relationOpts) > 0 {
		relations := make([]field.RelationField, 0, len(l.relationOpts))
		for _, opt := range l.relationOpts {
			relations = append(relations, opt(l.core))
		}
		if len(relations) > 0 {
			errFields = append(errFields, zap.Any("relations", relations))
			lr = lr.Preload(relations...)
		}
	}
	res, err := lr.Last()
	if err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			errFields = append(errFields, zap.Error(err))
			l.core.logger.Error("【{{.StructName}}.Last】失败", errFields...)
		}
		return nil, err
	}
	return res, nil
}
`
}

func (r *Repository) genListTemplate() string {
	return `// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"

    "github.com/gorm-gen/plugin/paginate"
	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"
	"gorm.io/gorm/clause"

	"{{.GenQueryPkg}}"

    "{{.RepoPkg}}"

    "{{.ModelPkg}}"
)

type list struct {
	core          *{{.StructName}}
	tx            *query.Query
	qTx           *query.QueryTx
	page          int
	pageSize      int
	lock          clause.Expression
	unscoped      bool
	selects       []field.Expr
	relationOpts  []RelationOption
	orderOpts     []OrderOption
	conditionOpts []ConditionOption
}

// List 获取数据列表
func ({{.Abbr}} *{{.StructName}}) List() *list {
	return &list{
		core:          {{.Abbr}},
		unscoped:      {{.Abbr}}.unscoped,
		selects:       make([]field.Expr, 0),
		relationOpts:  make([]RelationOption, 0),
		orderOpts:     make([]OrderOption, 0),
		conditionOpts: make([]ConditionOption, 0),
	}
}

// Tx 设置为事务
func (l *list) Tx(tx *query.Query) *list {
	l.tx = tx
	l.qTx = nil
	return l
}

// QueryTx 设置为手动事务
func (l *list) QueryTx(tx *query.QueryTx) *list {
	l.qTx = tx
	l.tx = nil
	return l
}

func (l *list) Select(field ...field.Expr) *list {
	l.selects = append(l.selects, field...)
	return l
}

func (l *list) ForUpdate() *list {
	l.lock = clause.Locking{Strength: clause.LockingStrengthUpdate}
	return l
}

func (l *list) ForUpdateSkipLocked() *list {
	l.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsSkipLocked}
	return l
}

func (l *list) ForUpdateNoWait() *list {
	l.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsNoWait}
	return l
}

func (l *list) ForShare() *list {
	l.lock = clause.Locking{Strength: clause.LockingStrengthShare}
	return l
}

func (l *list) ForShareSkipLocked() *list {
	l.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsSkipLocked}
	return l
}

func (l *list) ForShareNoWait() *list {
	l.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsNoWait}
	return l
}

func (l *list) Unscoped() *list {
	l.unscoped = true
	return l
}

func (l *list) Relation(opts ...RelationOption) *list {
	l.relationOpts = append(l.relationOpts, opts...)
	return l
}

func (l *list) Order(opts ...OrderOption) *list {
	l.orderOpts = append(l.orderOpts, opts...)
	return l
}

func (l *list) Where(opts ...ConditionOption) *list {
	l.conditionOpts = append(l.conditionOpts, opts...)
	return l
}

// Page 列表分页
func (l *list) Page(page, pageSize uint) *list {
	l.page = int(page)
	l.pageSize = int(pageSize)
	return l
}

// Do 执行获取数据列表
func (l *list) Do(ctx context.Context) ([]*{{.ModelName}}.{{.StructName}}, error) {
	lq := l.core.q.{{.StructName}}
	if l.tx != nil {
		lq = l.tx.{{.StructName}}
	}
	if l.qTx != nil {
		lq = l.qTx.{{.StructName}}
	}
	lr := lq.WithContext(ctx)
	if l.core.newTableName != nil && *l.core.newTableName != "" {
		lr = lq.Table(*l.core.newTableName).WithContext(ctx)
	}
	if len(l.selects) > 0 {
		if l.core.newTableName == nil {
			lr = lr.Select(l.selects...)
		} else {
			fs := make([]field.Expr, 0, len(l.selects))
			for _, v := range l.selects {
				fs = append(fs, field.NewField(*l.core.newTableName, v.ColumnName().String()))
			}
			lr = lr.Select(fs...)
		}
	}
	if l.unscoped {
		lr = lr.Unscoped()
	}
	if (l.tx != nil || l.qTx != nil) && l.lock != nil {
		lr = lr.Clauses(l.lock)
	}
	errFields := make([]zap.Field, 0)
	if len(l.conditionOpts) > 0 {
		conditions := make([]gen.Condition, 0, len(l.conditionOpts))
		for _, opt := range l.conditionOpts {
			conditions = append(conditions, opt(l.core))
		}
		if len(conditions) > 0 {
			errFields = append(errFields, zap.Any("conditions", conditions))
			lr = lr.Where(conditions...)
		}
	}
	if len(l.orderOpts) > 0 {
		orders := make([]field.Expr, 0, len(l.orderOpts))
		for _, opt := range l.orderOpts {
			orders = append(orders, opt(l.core))
		}
		if len(orders) > 0 {
			errFields = append(errFields, zap.Any("orders", orders))
			lr = lr.Order(orders...)
		}
	}
	if l.page > 0 && l.pageSize > 0 {
		errFields = append(errFields, zap.Int("page", l.page))
		errFields = append(errFields, zap.Int("pageSize", l.pageSize))
		lr = lr.Scopes(paginate.Gen(l.page, l.pageSize))
	}
	if len(l.relationOpts) > 0 {
		relations := make([]field.RelationField, 0, len(l.relationOpts))
		for _, opt := range l.relationOpts {
			relations = append(relations, opt(l.core))
		}
		if len(relations) > 0 {
			errFields = append(errFields, zap.Any("relations", relations))
			lr = lr.Preload(relations...)
		}
	}
	list, err := lr.Find()
	if err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			errFields = append(errFields, zap.Error(err))
			l.core.logger.Error("【{{.StructName}}.List】失败", errFields...)
		}
		return nil, err
	}
	return list, nil
}
`
}

func (r *Repository) genTakeTemplate() string {
	return `// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"

	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"
	"gorm.io/gorm/clause"

	"{{.GenQueryPkg}}"

    "{{.RepoPkg}}"

    "{{.ModelPkg}}"
)

type take struct {
	core          *{{.StructName}}
	tx            *query.Query
	qTx           *query.QueryTx
	lock          clause.Expression
	unscoped      bool
	selects       []field.Expr
	relationOpts  []RelationOption
	orderOpts     []OrderOption
	conditionOpts []ConditionOption
}

// Take 获取一条记录
func ({{.Abbr}} *{{.StructName}}) Take() *take {
	return &take{
		core:          {{.Abbr}},
		unscoped:      {{.Abbr}}.unscoped,
		selects:       make([]field.Expr, 0),
		relationOpts:  make([]RelationOption, 0),
		orderOpts:     make([]OrderOption, 0),
		conditionOpts: make([]ConditionOption, 0),
	}
}

// Tx 设置为事务
func (t *take) Tx(tx *query.Query) *take {
	t.tx = tx
	t.qTx = nil
	return t
}

// QueryTx 设置为手动事务
func (t *take) QueryTx(tx *query.QueryTx) *take {
	t.qTx = tx
	t.tx = nil
	return t
}

func (t *take) Select(field ...field.Expr) *take {
	t.selects = append(t.selects, field...)
	return t
}

func (t *take) ForUpdate() *take {
	t.lock = clause.Locking{Strength: clause.LockingStrengthUpdate}
	return t
}

func (t *take) ForUpdateSkipLocked() *take {
	t.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsSkipLocked}
	return t
}

func (t *take) ForUpdateNoWait() *take {
	t.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsNoWait}
	return t
}

func (t *take) ForShare() *take {
	t.lock = clause.Locking{Strength: clause.LockingStrengthShare}
	return t
}

func (t *take) ForShareSkipLocked() *take {
	t.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsSkipLocked}
	return t
}

func (t *take) ForShareNoWait() *take {
	t.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsNoWait}
	return t
}

func (t *take) Unscoped() *take {
	t.unscoped = true
	return t
}

func (t *take) Relation(opts ...RelationOption) *take {
	t.relationOpts = append(t.relationOpts, opts...)
	return t
}

func (t *take) Order(opts ...OrderOption) *take {
	t.orderOpts = append(t.orderOpts, opts...)
	return t
}

func (t *take) Where(opts ...ConditionOption) *take {
	t.conditionOpts = append(t.conditionOpts, opts...)
	return t
}

// Do 执行获取一条记录
func (t *take) Do(ctx context.Context) (*{{.ModelName}}.{{.StructName}}, error) {
	tq := t.core.q.{{.StructName}}
	if t.tx != nil {
		tq = t.tx.{{.StructName}}
	}
	if t.qTx != nil {
		tq = t.qTx.{{.StructName}}
	}
	tr := tq.WithContext(ctx)
	if t.core.newTableName != nil && *t.core.newTableName != "" {
		tr = tq.Table(*t.core.newTableName).WithContext(ctx)
	}
	if len(t.selects) > 0 {
		if t.core.newTableName == nil {
			tr = tr.Select(t.selects...)
		} else {
			fs := make([]field.Expr, 0, len(t.selects))
			for _, v := range t.selects {
				fs = append(fs, field.NewField(*t.core.newTableName, v.ColumnName().String()))
			}
			tr = tr.Select(fs...)
		}
	}
	if t.unscoped {
		tr = tr.Unscoped()
	}
	if (t.tx != nil || t.qTx != nil) && t.lock != nil {
		tr = tr.Clauses(t.lock)
	}
	errFields := make([]zap.Field, 0)
	if len(t.conditionOpts) > 0 {
		conditions := make([]gen.Condition, 0, len(t.conditionOpts))
		for _, opt := range t.conditionOpts {
			conditions = append(conditions, opt(t.core))
		}
		if len(conditions) > 0 {
			errFields = append(errFields, zap.Any("conditions", conditions))
			tr = tr.Where(conditions...)
		}
	}
	if len(t.orderOpts) > 0 {
		orders := make([]field.Expr, 0, len(t.orderOpts))
		for _, opt := range t.orderOpts {
			orders = append(orders, opt(t.core))
		}
		if len(orders) > 0 {
			errFields = append(errFields, zap.Any("orders", orders))
			tr = tr.Order(orders...)
		}
	}
	if len(t.relationOpts) > 0 {
		relations := make([]field.RelationField, 0, len(t.relationOpts))
		for _, opt := range t.relationOpts {
			relations = append(relations, opt(t.core))
		}
		if len(relations) > 0 {
			errFields = append(errFields, zap.Any("relations", relations))
			tr = tr.Preload(relations...)
		}
	}
	res, err := tr.Take()
	if err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			errFields = append(errFields, zap.Error(err))
			t.core.logger.Error("【{{.StructName}}.Take】失败", errFields...)
		}
		return nil, err
	}
	return res, nil
}
`
}

func (r *Repository) genUpdateTemplate() string {
	return `// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"

	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"

	"{{.GenQueryPkg}}"

    "{{.RepoPkg}}"
)

type update struct {
	core          *{{.StructName}}
	tx            *query.Query
	qTx           *query.QueryTx
	unscoped      bool
	updateOpts    []UpdateOption
	conditionOpts []ConditionOption
}

// Update 更新数据
func ({{.Abbr}} *{{.StructName}}) Update() *update {
	return &update{
		core:          {{.Abbr}},
		unscoped:      {{.Abbr}}.unscoped,
		updateOpts:    make([]UpdateOption, 0),
		conditionOpts: make([]ConditionOption, 0),
	}
}

// Tx 设置为事务
func (u *update) Tx(tx *query.Query) *update {
	u.tx = tx
	u.qTx = nil
	return u
}

// QueryTx 设置为手动事务
func (u *update) QueryTx(tx *query.QueryTx) *update {
	u.qTx = tx
	u.tx = nil
	return u
}

func (u *update) Unscoped() *update {
	u.unscoped = true
	return u
}

func (u *update) Update(opts ...UpdateOption) *update {
	u.updateOpts = append(u.updateOpts, opts...)
	return u
}

func (u *update) Where(opts ...ConditionOption) *update {
	u.conditionOpts = append(u.conditionOpts, opts...)
	return u
}

// Do 执行更新数据
func (u *update) Do(ctx context.Context) (int64, error) {
	if len(u.updateOpts) == 0 {
		return 0, nil
	}
	uq := u.core.q.{{.StructName}}
	if u.tx != nil {
		uq = u.tx.{{.StructName}}
	}
	if u.qTx != nil {
		uq = u.qTx.{{.StructName}}
	}
	ur := uq.WithContext(ctx)
	if u.core.newTableName != nil && *u.core.newTableName != "" {
		ur = uq.Table(*u.core.newTableName).WithContext(ctx)
	}
	if u.unscoped {
		ur = ur.Unscoped()
	}
	errFields := make([]zap.Field, 0)
	if len(u.conditionOpts) > 0 {
		conditions := make([]gen.Condition, 0, len(u.conditionOpts))
		for _, opt := range u.conditionOpts {
			conditions = append(conditions, opt(u.core))
		}
		if len(conditions) > 0 {
			errFields = append(errFields, zap.Any("conditions", conditions))
			ur = ur.Where(conditions...)
		}
	}
	columns := make([]field.AssignExpr, 0, len(u.updateOpts))
	for _, opt := range u.updateOpts {
		columns = append(columns, opt(u.core))
	}
	if len(columns) == 0 {
		return 0, nil
	}
	res, err := ur.UpdateSimple(columns...)
	if err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			errFields = append(errFields, zap.Any("columns", columns))
			errFields = append(errFields, zap.Error(err))
			u.core.logger.Error("【{{.StructName}}.Update】失败", errFields...)
		}
		return 0, err
	}
	return res.RowsAffected, nil
}
`
}

func (r *Repository) genSumTemplate() string {
	return `// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.

package {{.Package}}

import (
	"context"

	"github.com/shopspring/decimal"
	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"

	"{{.GenQueryPkg}}"

	"{{.RepoPkg}}"
)

type sum struct {
	core          *{{.StructName}}
	tx            *query.Query
	qTx           *query.QueryTx
	unscoped      bool
	genField      field.Expr
	conditionOpts []ConditionOption
}

// Sum SUM数据
func ({{.Abbr}} *{{.StructName}}) Sum(genField field.Expr) *sum {
	return &sum{
		core:          {{.Abbr}},
		unscoped:      {{.Abbr}}.unscoped,
		genField:      genField,
		conditionOpts: make([]ConditionOption, 0),
	}
}

// Tx 设置为事务
func (s *sum) Tx(tx *query.Query) *sum {
	s.tx = tx
	s.qTx = nil
	return s
}

// SetQueryTx 设置为手动事务
func (s *sum) QueryTx(tx *query.QueryTx) *sum {
	s.qTx = tx
	s.tx = nil
	return s
}

func (s *sum) Unscoped() *sum {
	s.unscoped = true
	return s
}

func (s *sum) Where(opts ...ConditionOption) *sum {
	s.conditionOpts = append(s.conditionOpts, opts...)
	return s
}
` + "\ntype Sum struct {\n    Sum decimal.Decimal `json:\"sum\"`\n}\n\n" + `// Do 执行SUM数据
func (s *sum) Do(ctx context.Context) (decimal.Decimal, error) {
	sq := s.core.q.{{.StructName}}
	if s.tx != nil {
		sq = s.tx.{{.StructName}}
	}
	if s.qTx != nil {
		sq = s.qTx.{{.StructName}}
	}
	expr := field.NewField("", s.genField.ColumnName().String()).Sum().As("sum")
	sr := sq.WithContext(ctx)
	if s.core.newTableName != nil && *s.core.newTableName != "" {
		sr = sq.Table(*s.core.newTableName).WithContext(ctx)
	}
	sr = sr.Select(expr)
	if s.unscoped {
		sr = sr.Unscoped()
	}
	errFields := make([]zap.Field, 0)
	if len(s.conditionOpts) > 0 {
		conditions := make([]gen.Condition, 0, len(s.conditionOpts))
		for _, opt := range s.conditionOpts {
			conditions = append(conditions, opt(s.core))
		}
		if len(conditions) > 0 {
			errFields = append(errFields, zap.Any("conditions", conditions))
			sr = sr.Where(conditions...)
		}
	}
	var data Sum
	if err := sr.Scan(&data); err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			errFields = append(errFields, zap.String("field", s.genField.ColumnName().String()))
			errFields = append(errFields, zap.Error(err))
			s.core.logger.Error("【{{.StructName}}.Sum】失败", errFields...)
		}
		return decimal.Zero, err
	}
	return data.Sum, nil
}
`
}
