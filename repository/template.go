package repository

func (r *Repository) baseTemplate() string {
	return `// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"errors"
	"sync"

	"gorm.io/gorm"

	"{{.GormDBVarPkg}}"

	"{{.GenQueryPkg}}"
)

var once sync.Once
var q *query.Query

func GetQuery() *query.Query {
	once.Do(func() {
		q = query.Use({{.GormDBVar}})
	})
	return q
}

// IsRealErr 是否为非超时和查询不到的错误
func IsRealErr(err error) bool {
	return !errors.Is(err, gorm.ErrRecordNotFound) &&
		!errors.Is(err, context.DeadlineExceeded) &&
		!errors.Is(err, context.Canceled)
}
`
}

func (r *Repository) genBaseTemplate() string {
	return `// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.

package {{.Package}}

import (
{{range .Imports}}{{.}}{{end}}
)

type {{.StructName}} struct {
	q      *query.Query
	logger *zap.Logger
}

type Option func(*{{.StructName}})

func WithQuery(q *query.Query) Option {
	return func({{.Abbr}} *{{.StructName}}) {
		{{.Abbr}}.q = q
	}
}

func WithLogger(logger *zap.Logger) Option {
	return func({{.Abbr}} *{{.StructName}}) {
		{{.Abbr}}.logger = logger
	}
}

func New(opts ...Option) *{{.StructName}} {
	{{.Abbr}} := &{{.StructName}}{
		q:      {{.RepoPkgName}}.GetQuery(),
		logger: global.Logger,
	}
	for _, opt := range opts {
		opt({{.Abbr}})
	}
	return {{.Abbr}}
}

type ConditionOption func(*{{.StructName}}) gen.Condition

func Condition(condition gen.Condition) ConditionOption {
	return func(*{{.StructName}}) gen.Condition {
		return condition
	}
}

{{range .Conditions}}{{.}}` + "\n" + `{{end}}

type UpdateOption func(*{{.StructName}}) field.AssignExpr

type OrderOption func(*{{.StructName}}) field.Expr

func OrderIDDesc() OrderOption {
	return func({{.Abbr}} *{{.StructName}}) field.Expr {
		return {{.Abbr}}.q.{{.StructName}}.ID.Desc()
	}
}

type RelationOption func(*{{.StructName}}) field.RelationField

func RelationAll() RelationOption {
	return func({{.Abbr}} *{{.StructName}}) field.RelationField {
		return field.Associations
	}
}
`
}

func (r *Repository) genCountTemplate() string {
	return `// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.

package {{.Package}}

import (
	"context"

	"go.uber.org/zap"
	"gorm.io/gen"

	"{{.GenQueryPkg}}"

    "{{.RepoPkg}}"
)

type CountData struct {
	tx            *query.Query
	qTx           *query.QueryTx
	unscoped      bool
	conditionOpts []ConditionOption
}

func NewCountData() *CountData {
	return &CountData{
		conditionOpts: make([]ConditionOption, 0),
	}
}

func (c *CountData) SetTx(tx *query.Query) *CountData {
	c.tx = tx
	c.qTx = nil
	return c
}

// SetQueryTx 设置为手动事务
func (c *CountData) SetQueryTx(tx *query.QueryTx) *CountData {
	c.qTx = tx
	c.tx = nil
	return c
}

func (c *CountData) SetUnscoped() *CountData {
	c.unscoped = true
	return c
}

func (c *CountData) SetConditionOpts(opts ...ConditionOption) *CountData {
	c.conditionOpts = opts
	return c
}

// Count 获取数据总条数
func ({{.Abbr}} *{{.StructName}}) Count(ctx context.Context, cd *CountData) (int64, error) {
	{{.Abbr}}q := {{.Abbr}}.q.{{.StructName}}
	if cd.tx != nil {
		{{.Abbr}}q = cd.tx.{{.StructName}}
	}
	if cd.qTx != nil {
		{{.Abbr}}q = cd.qTx.{{.StructName}}
	}
	{{.Abbr}}r := {{.Abbr}}q.WithContext(ctx)
	if cd.unscoped {
		{{.Abbr}}r = {{.Abbr}}r.Unscoped()
	}
	errFields := make([]zap.Field, 0)
	if len(cd.conditionOpts) > 0 {
		conditions := make([]gen.Condition, 0, len(cd.conditionOpts))
		for _, opt := range cd.conditionOpts {
			conditions = append(conditions, opt({{.Abbr}}))
		}
		if len(conditions) > 0 {
			errFields = append(errFields, zap.Any("conditions", conditions))
			{{.Abbr}}r = {{.Abbr}}r.Where(conditions...)
		}
	}
	count, err := {{.Abbr}}r.Count()
	if err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			errFields = append(errFields, zap.Error(err))
			{{.Abbr}}.logger.Error("【{{.StructName}}.Count】失败", errFields...)
		}
		return 0, err
	}
	return count, nil
}
`
}

func (r *Repository) genCreateTemplate() string {
	return `// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.

package {{.Package}}

import (
	"context"

	"go.uber.org/zap"

	"{{.GenQueryPkg}}"

    "{{.RepoPkg}}"

    "{{.ModelPkg}}"
)

type CreateData struct {
	tx        *query.Query
	qTx       *query.QueryTx
	unscoped  bool
	values    []*{{.ModelName}}.{{.StructName}}
	batchSize int
}

func NewCreateData() *CreateData {
	return &CreateData{}
}

func (c *CreateData) SetTx(tx *query.Query) *CreateData {
	c.tx = tx
	c.qTx = nil
	return c
}

// SetQueryTx 设置为手动事务
func (c *CreateData) SetQueryTx(tx *query.QueryTx) *CreateData {
	c.qTx = tx
	c.tx = nil
	return c
}

func (c *CreateData) SetUnscoped() *CreateData {
	c.unscoped = true
	return c
}

func (c *CreateData) SetValues(values ...*{{.ModelName}}.{{.StructName}}) *CreateData {
	c.values = values
	return c
}

func (c *CreateData) SetBatchSize(batchSize uint) *CreateData {
	c.batchSize = int(batchSize)
	return c
}

// Create 添加数据
func ({{.Abbr}} *{{.StructName}}) Create(ctx context.Context, cd *CreateData) (err error) {
	length := len(cd.values)
	if length == 0 {
		return nil
	}
	{{.Abbr}}q := {{.Abbr}}.q.{{.StructName}}
	if cd.tx != nil {
		{{.Abbr}}q = cd.tx.{{.StructName}}
	}
	if cd.qTx != nil {
		{{.Abbr}}q = cd.qTx.{{.StructName}}
	}
	{{.Abbr}}r := {{.Abbr}}q.WithContext(ctx)
	if cd.unscoped {
		{{.Abbr}}r = {{.Abbr}}r.Unscoped()
	}
	errFields := make([]zap.Field, 0)
	if length > 1 && cd.batchSize > 0 {
		errFields = append(errFields, zap.Int("batchSize", cd.batchSize))
		err = {{.Abbr}}r.CreateInBatches(cd.values, cd.batchSize)
	} else {
		err = {{.Abbr}}r.Create(cd.values...)
	}
	if err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			errFields = append(errFields, zap.Any("values", cd.values))
			errFields = append(errFields, zap.Error(err))
			{{.Abbr}}.logger.Error("【{{.StructName}}.Create】失败", errFields...)
		}
		return err
	}
	return nil
}
`
}

func (r *Repository) genDeleteTemplate() string {
	return `// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.

package {{.Package}}

import (
	"context"

	"go.uber.org/zap"
    "gorm.io/gen"

	"{{.GenQueryPkg}}"

    "{{.RepoPkg}}"
)

type DeleteData struct {
	tx            *query.Query
	qTx           *query.QueryTx
	unscoped      bool
	conditionOpts []ConditionOption
}

func NewDeleteData() *DeleteData {
	return &DeleteData{
		conditionOpts: make([]ConditionOption, 0),
	}
}

func (d *DeleteData) SetTx(tx *query.Query) *DeleteData {
	d.tx = tx
	d.qTx = nil
	return d
}

// SetQueryTx 设置为手动事务
func (d *DeleteData) SetQueryTx(tx *query.QueryTx) *DeleteData {
	d.qTx = tx
	d.tx = nil
	return d
}

func (d *DeleteData) SetUnscoped() *DeleteData {
	d.unscoped = true
	return d
}

func (d *DeleteData) SetConditionOpts(opts ...ConditionOption) *DeleteData {
	d.conditionOpts = opts
	return d
}

// Delete 删除数据
func ({{.Abbr}} *{{.StructName}}) Delete(ctx context.Context, dd *DeleteData) (int64, error) {
	{{.Abbr}}q := {{.Abbr}}.q.{{.StructName}}
	if dd.tx != nil {
		{{.Abbr}}q = dd.tx.{{.StructName}}
	}
	if dd.qTx != nil {
		{{.Abbr}}q = dd.qTx.{{.StructName}}
	}
	{{.Abbr}}r := {{.Abbr}}q.WithContext(ctx)
	if dd.unscoped {
		{{.Abbr}}r = {{.Abbr}}r.Unscoped()
	}
	errFields := make([]zap.Field, 0)
	if len(dd.conditionOpts) > 0 {
		conditions := make([]gen.Condition, 0, len(dd.conditionOpts))
		for _, opt := range dd.conditionOpts {
			conditions = append(conditions, opt({{.Abbr}}))
		}
		if len(conditions) > 0 {
			errFields = append(errFields, zap.Any("conditions", conditions))
			{{.Abbr}}r = {{.Abbr}}r.Where(conditions...)
		}
	}
	res, err := {{.Abbr}}r.Delete()
	if err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			errFields = append(errFields, zap.Error(err))
			{{.Abbr}}.logger.Error("【{{.StructName}}.Delete】失败", errFields...)
		}
		return 0, err
	}
	return res.RowsAffected, nil
}
`
}

func (r *Repository) genFirstTemplate() string {
	return `// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.

package {{.Package}}

import (
	"context"

	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"
	"gorm.io/gorm/clause"

	"{{.GenQueryPkg}}"

    "{{.RepoPkg}}"

    "{{.ModelPkg}}"
)

type FirstData struct {
	tx            *query.Query
	qTx           *query.QueryTx
	forUpdate     bool
	unscoped      bool
	relationOpts  []RelationOption
	conditionOpts []ConditionOption
}

func NewFirstData() *FirstData {
	return &FirstData{
		relationOpts:  make([]RelationOption, 0),
		conditionOpts: make([]ConditionOption, 0),
	}
}

func (f *FirstData) SetTx(tx *query.Query) *FirstData {
	f.tx = tx
	f.qTx = nil
	return f
}

// SetQueryTx 设置为手动事务
func (f *FirstData) SetQueryTx(tx *query.QueryTx) *FirstData {
	f.qTx = tx
	f.tx = nil
	return f
}

func (f *FirstData) SetForUpdate(forUpdate bool) *FirstData {
	f.forUpdate = forUpdate
	return f
}

func (f *FirstData) SetUnscoped() *FirstData {
	f.unscoped = true
	return f
}

func (f *FirstData) SetRelationOpts(opts ...RelationOption) *FirstData {
	f.relationOpts = opts
	return f
}

func (f *FirstData) SetConditionOpts(opts ...ConditionOption) *FirstData {
	f.conditionOpts = opts
	return f
}

// First 获取首条数据
func ({{.Abbr}} *{{.StructName}}) First(ctx context.Context, fd *FirstData) (*{{.ModelName}}.{{.StructName}}, error) {
	{{.Abbr}}q := {{.Abbr}}.q.{{.StructName}}
	if fd.tx != nil {
		{{.Abbr}}q = fd.tx.{{.StructName}}
	}
	if fd.qTx != nil {
		{{.Abbr}}q = fd.qTx.{{.StructName}}
	}
	{{.Abbr}}r := {{.Abbr}}q.WithContext(ctx)
	if fd.unscoped {
		{{.Abbr}}r = {{.Abbr}}r.Unscoped()
	}
	if (fd.tx != nil || fd.qTx != nil) && fd.forUpdate {
		{{.Abbr}}r = {{.Abbr}}r.Clauses(clause.Locking{Strength: "UPDATE"})
	}
	errFields := make([]zap.Field, 0)
	if len(fd.conditionOpts) > 0 {
		conditions := make([]gen.Condition, 0, len(fd.conditionOpts))
		for _, opt := range fd.conditionOpts {
			conditions = append(conditions, opt({{.Abbr}}))
		}
		if len(conditions) > 0 {
			errFields = append(errFields, zap.Any("conditions", conditions))
			{{.Abbr}}r = {{.Abbr}}r.Where(conditions...)
		}
	}
	if len(fd.relationOpts) > 0 {
		relations := make([]field.RelationField, 0, len(fd.relationOpts))
		for _, opt := range fd.relationOpts {
			relations = append(relations, opt({{.Abbr}}))
		}
		if len(relations) > 0 {
			errFields = append(errFields, zap.Any("relations", relations))
			{{.Abbr}}r = {{.Abbr}}r.Preload(relations...)
		}
	}
	res, err := {{.Abbr}}r.First()
	if err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			errFields = append(errFields, zap.Error(err))
			{{.Abbr}}.logger.Error("【{{.StructName}}.First】失败", errFields...)
		}
		return nil, err
	}
	return res, nil
}
`
}

func (r *Repository) genLastTemplate() string {
	return `// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.

package {{.Package}}

import (
	"context"

	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"
	"gorm.io/gorm/clause"

	"{{.GenQueryPkg}}"

    "{{.RepoPkg}}"

    "{{.ModelPkg}}"
)

type LastData struct {
	tx            *query.Query
	qTx           *query.QueryTx
	forUpdate     bool
	unscoped      bool
	relationOpts  []RelationOption
	conditionOpts []ConditionOption
}

func NewLastData() *LastData {
	return &LastData{
		relationOpts:  make([]RelationOption, 0),
		conditionOpts: make([]ConditionOption, 0),
	}
}

func (l *LastData) SetTx(tx *query.Query) *LastData {
	l.tx = tx
	l.qTx = nil
	return l
}

// SetQueryTx 设置为手动事务
func (l *LastData) SetQueryTx(tx *query.QueryTx) *LastData {
	l.qTx = tx
	l.tx = nil
	return l
}

func (l *LastData) SetForUpdate(forUpdate bool) *LastData {
	l.forUpdate = forUpdate
	return l
}

func (l *LastData) SetUnscoped() *LastData {
	l.unscoped = true
	return l
}

func (l *LastData) SetRelationOpts(opts ...RelationOption) *LastData {
	l.relationOpts = opts
	return l
}

func (l *LastData) SetConditionOpts(opts ...ConditionOption) *LastData {
	l.conditionOpts = opts
	return l
}

// Last 获取最后一条数据
func ({{.Abbr}} *{{.StructName}}) Last(ctx context.Context, ld *LastData) (*{{.ModelName}}.{{.StructName}}, error) {
	{{.Abbr}}q := {{.Abbr}}.q.{{.StructName}}
	if ld.tx != nil {
		{{.Abbr}}q = ld.tx.{{.StructName}}
	}
	if ld.qTx != nil {
		{{.Abbr}}q = ld.qTx.{{.StructName}}
	}
	{{.Abbr}}r := {{.Abbr}}q.WithContext(ctx)
	if ld.unscoped {
		{{.Abbr}}r = {{.Abbr}}r.Unscoped()
	}
	if (ld.tx != nil || ld.qTx != nil) && ld.forUpdate {
		{{.Abbr}}r = {{.Abbr}}r.Clauses(clause.Locking{Strength: "UPDATE"})
	}
	errFields := make([]zap.Field, 0)
	if len(ld.conditionOpts) > 0 {
		conditions := make([]gen.Condition, 0, len(ld.conditionOpts))
		for _, opt := range ld.conditionOpts {
			conditions = append(conditions, opt({{.Abbr}}))
		}
		if len(conditions) > 0 {
			errFields = append(errFields, zap.Any("conditions", conditions))
			{{.Abbr}}r = {{.Abbr}}r.Where(conditions...)
		}
	}
	if len(ld.relationOpts) > 0 {
		relations := make([]field.RelationField, 0, len(ld.relationOpts))
		for _, opt := range ld.relationOpts {
			relations = append(relations, opt({{.Abbr}}))
		}
		if len(relations) > 0 {
			errFields = append(errFields, zap.Any("relations", relations))
			{{.Abbr}}r = {{.Abbr}}r.Preload(relations...)
		}
	}
	res, err := {{.Abbr}}r.Last()
	if err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			errFields = append(errFields, zap.Error(err))
			{{.Abbr}}.logger.Error("【{{.StructName}}.Last】失败", errFields...)
		}
		return nil, err
	}
	return res, nil
}
`
}

func (r *Repository) genListTemplate() string {
	return `// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.

package {{.Package}}

import (
	"context"

    "github.com/gorm-gen/plugin/paginate"
	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"
	"gorm.io/gorm/clause"

	"{{.GenQueryPkg}}"

    "{{.RepoPkg}}"

    "{{.ModelPkg}}"
)

type ListData struct {
	tx            *query.Query
	qTx           *query.QueryTx
	page          int
	pageSize      int
	forUpdate     bool
	unscoped      bool
	relationOpts  []RelationOption
	orderOpts     []OrderOption
	conditionOpts []ConditionOption
}

func NewListData() *ListData {
	return &ListData{
		relationOpts:  make([]RelationOption, 0),
		orderOpts:     make([]OrderOption, 0),
		conditionOpts: make([]ConditionOption, 0),
	}
}

func (l *ListData) SetTx(tx *query.Query) *ListData {
	l.tx = tx
	l.qTx = nil
	return l
}

// SetQueryTx 设置为手动事务
func (l *ListData) SetQueryTx(tx *query.QueryTx) *ListData {
	l.qTx = tx
	l.tx = nil
	return l
}

func (l *ListData) SetForUpdate(forUpdate bool) *ListData {
	l.forUpdate = forUpdate
	return l
}

func (l *ListData) SetUnscoped() *ListData {
	l.unscoped = true
	return l
}

func (l *ListData) SetRelationOpts(opts ...RelationOption) *ListData {
	l.relationOpts = opts
	return l
}

func (l *ListData) SetOrderOpts(opts ...OrderOption) *ListData {
	l.orderOpts = opts
	return l
}

func (l *ListData) SetConditionOpts(opts ...ConditionOption) *ListData {
	l.conditionOpts = opts
	return l
}

func (l *ListData) SetPage(page, pageSize uint) *ListData {
	l.page = int(page)
	l.pageSize = int(pageSize)
	return l
}

// List 获取数据列表
func ({{.Abbr}} *{{.StructName}}) List(ctx context.Context, ld *ListData) ([]*{{.ModelName}}.{{.StructName}}, error) {
	{{.Abbr}}q := {{.Abbr}}.q.{{.StructName}}
	if ld.tx != nil {
		{{.Abbr}}q = ld.tx.{{.StructName}}
	}
	if ld.qTx != nil {
		{{.Abbr}}q = ld.qTx.{{.StructName}}
	}
	{{.Abbr}}r := {{.Abbr}}q.WithContext(ctx)
	if ld.unscoped {
		{{.Abbr}}r = {{.Abbr}}r.Unscoped()
	}
	if (ld.tx != nil || ld.qTx != nil) && ld.forUpdate {
		{{.Abbr}}r = {{.Abbr}}r.Clauses(clause.Locking{Strength: "UPDATE"})
	}
	errFields := make([]zap.Field, 0)
	if len(ld.conditionOpts) > 0 {
		conditions := make([]gen.Condition, 0, len(ld.conditionOpts))
		for _, opt := range ld.conditionOpts {
			conditions = append(conditions, opt({{.Abbr}}))
		}
		if len(conditions) > 0 {
			errFields = append(errFields, zap.Any("conditions", conditions))
			{{.Abbr}}r = {{.Abbr}}r.Where(conditions...)
		}
	}
	if len(ld.orderOpts) > 0 {
		orders := make([]field.Expr, 0, len(ld.orderOpts))
		for _, opt := range ld.orderOpts {
			orders = append(orders, opt({{.Abbr}}))
		}
		if len(orders) > 0 {
			errFields = append(errFields, zap.Any("orders", orders))
			{{.Abbr}}r = {{.Abbr}}r.Order(orders...)
		}
	}
	if ld.page > 0 && ld.pageSize > 0 {
		errFields = append(errFields, zap.Int("page", ld.page))
		errFields = append(errFields, zap.Int("pageSize", ld.pageSize))
		{{.Abbr}}r = {{.Abbr}}r.Scopes(paginate.Gen(ld.page, ld.pageSize))
	}
	if len(ld.relationOpts) > 0 {
		relations := make([]field.RelationField, 0, len(ld.relationOpts))
		for _, opt := range ld.relationOpts {
			relations = append(relations, opt({{.Abbr}}))
		}
		if len(relations) > 0 {
			errFields = append(errFields, zap.Any("relations", relations))
			{{.Abbr}}r = {{.Abbr}}r.Preload(relations...)
		}
	}
	list, err := {{.Abbr}}r.Find()
	if err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			errFields = append(errFields, zap.Error(err))
			{{.Abbr}}.logger.Error("【{{.StructName}}.List】失败", errFields...)
		}
		return nil, err
	}
	return list, nil
}
`
}

func (r *Repository) genTakeTemplate() string {
	return `// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.

package {{.Package}}

import (
	"context"

	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"
	"gorm.io/gorm/clause"

	"{{.GenQueryPkg}}"

    "{{.RepoPkg}}"

    "{{.ModelPkg}}"
)

type TakeData struct {
	tx            *query.Query
	qTx           *query.QueryTx
	forUpdate     bool
	unscoped      bool
	relationOpts  []RelationOption
	orderOpts     []OrderOption
	conditionOpts []ConditionOption
}

func NewTakeData() *TakeData {
	return &TakeData{
		relationOpts:  make([]RelationOption, 0),
		orderOpts:     make([]OrderOption, 0),
		conditionOpts: make([]ConditionOption, 0),
	}
}

func (t *TakeData) SetTx(tx *query.Query) *TakeData {
	t.tx = tx
	t.qTx = nil
	return t
}

// SetQueryTx 设置为手动事务
func (t *TakeData) SetQueryTx(tx *query.QueryTx) *TakeData {
	t.qTx = tx
	t.tx = nil
	return t
}

func (t *TakeData) SetForUpdate(forUpdate bool) *TakeData {
	t.forUpdate = forUpdate
	return t
}

func (t *TakeData) SetUnscoped() *TakeData {
	t.unscoped = true
	return t
}

func (t *TakeData) SetRelationOpts(opts ...RelationOption) *TakeData {
	t.relationOpts = opts
	return t
}

func (t *TakeData) SetOrderOpts(opts ...OrderOption) *TakeData {
	t.orderOpts = opts
	return t
}

func (t *TakeData) SetConditionOpts(opts ...ConditionOption) *TakeData {
	t.conditionOpts = opts
	return t
}

// Take 获取一条数据
func ({{.Abbr}} *{{.StructName}}) Take(ctx context.Context, td *TakeData) (*{{.ModelName}}.{{.StructName}}, error) {
	{{.Abbr}}q := {{.Abbr}}.q.{{.StructName}}
	if td.tx != nil {
		{{.Abbr}}q = td.tx.{{.StructName}}
	}
	if td.qTx != nil {
		{{.Abbr}}q = td.qTx.{{.StructName}}
	}
	{{.Abbr}}r := {{.Abbr}}q.WithContext(ctx)
	if td.unscoped {
		{{.Abbr}}r = {{.Abbr}}r.Unscoped()
	}
	if (td.tx != nil || td.qTx != nil) && td.forUpdate {
		{{.Abbr}}r = {{.Abbr}}r.Clauses(clause.Locking{Strength: "UPDATE"})
	}
	errFields := make([]zap.Field, 0)
	if len(td.conditionOpts) > 0 {
		conditions := make([]gen.Condition, 0, len(td.conditionOpts))
		for _, opt := range td.conditionOpts {
			conditions = append(conditions, opt({{.Abbr}}))
		}
		if len(conditions) > 0 {
			errFields = append(errFields, zap.Any("conditions", conditions))
			{{.Abbr}}r = {{.Abbr}}r.Where(conditions...)
		}
	}
	if len(td.orderOpts) > 0 {
		orders := make([]field.Expr, 0, len(td.orderOpts))
		for _, opt := range td.orderOpts {
			orders = append(orders, opt({{.Abbr}}))
		}
		if len(orders) > 0 {
			errFields = append(errFields, zap.Any("orders", orders))
			{{.Abbr}}r = {{.Abbr}}r.Order(orders...)
		}
	}
	if len(td.relationOpts) > 0 {
		relations := make([]field.RelationField, 0, len(td.relationOpts))
		for _, opt := range td.relationOpts {
			relations = append(relations, opt({{.Abbr}}))
		}
		if len(relations) > 0 {
			errFields = append(errFields, zap.Any("relations", relations))
			{{.Abbr}}r = {{.Abbr}}r.Preload(relations...)
		}
	}
	res, err := {{.Abbr}}r.Take()
	if err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			errFields = append(errFields, zap.Error(err))
			{{.Abbr}}.logger.Error("【{{.StructName}}.Take】失败", errFields...)
		}
		return nil, err
	}
	return res, nil
}
`
}

func (r *Repository) genUpdateTemplate() string {
	return `// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin. DO NOT EDIT.

package {{.Package}}

import (
	"context"

	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"

	"{{.GenQueryPkg}}"

    "{{.RepoPkg}}"
)

type UpdateData struct {
	tx            *query.Query
	qTx           *query.QueryTx
	unscoped      bool
	updateOpts    []UpdateOption
	conditionOpts []ConditionOption
}

func NewUpdateData() *UpdateData {
	return &UpdateData{
		updateOpts:    make([]UpdateOption, 0),
		conditionOpts: make([]ConditionOption, 0),
	}
}

func (u *UpdateData) SetTx(tx *query.Query) *UpdateData {
	u.tx = tx
	u.qTx = nil
	return u
}

// SetQueryTx 设置为手动事务
func (u *UpdateData) SetQueryTx(tx *query.QueryTx) *UpdateData {
	u.qTx = tx
	u.tx = nil
	return u
}

func (u *UpdateData) SetUnscoped() *UpdateData {
	u.unscoped = true
	return u
}

func (u *UpdateData) SetUpdateOpts(opts ...UpdateOption) *UpdateData {
	u.updateOpts = opts
	return u
}

func (u *UpdateData) SetConditionOpts(opts ...ConditionOption) *UpdateData {
	u.conditionOpts = opts
	return u
}

// Update 更新数据
func ({{.Abbr}} *{{.StructName}}) Update(ctx context.Context, ud *UpdateData) (int64, error) {
	if len(ud.updateOpts) == 0 {
		return 0, nil
	}
	{{.Abbr}}q := {{.Abbr}}.q.{{.StructName}}
	if ud.tx != nil {
		{{.Abbr}}q = ud.tx.{{.StructName}}
	}
	if ud.qTx != nil {
		{{.Abbr}}q = ud.qTx.{{.StructName}}
	}
	{{.Abbr}}r := {{.Abbr}}q.WithContext(ctx)
	if ud.unscoped {
		{{.Abbr}}r = {{.Abbr}}r.Unscoped()
	}
	errFields := make([]zap.Field, 0)
	if len(ud.conditionOpts) > 0 {
		conditions := make([]gen.Condition, 0, len(ud.conditionOpts))
		for _, opt := range ud.conditionOpts {
			conditions = append(conditions, opt({{.Abbr}}))
		}
		if len(conditions) > 0 {
			errFields = append(errFields, zap.Any("conditions", conditions))
			{{.Abbr}}r = {{.Abbr}}r.Where(conditions...)
		}
	}
	columns := make([]field.AssignExpr, 0, len(ud.updateOpts))
	for _, opt := range ud.updateOpts {
		columns = append(columns, opt({{.Abbr}}))
	}
	if len(columns) == 0 {
		return 0, nil
	}
	res, err := {{.Abbr}}r.UpdateSimple(columns...)
	if err != nil {
		if {{.RepoPkgName}}.IsRealErr(err) {
			errFields = append(errFields, zap.Any("columns", columns))
			errFields = append(errFields, zap.Error(err))
			{{.Abbr}}.logger.Error("【{{.StructName}}.Update】失败", errFields...)
		}
		return 0, err
	}
	return res.RowsAffected, nil
}
`
}
